"""
Model code generator from schema state.

Generates Python source code for ``BaseSurrealModel`` subclasses from
a ``SchemaState`` obtained via ``DatabaseIntrospector``.  This is the
reverse of the ``ModelIntrospector`` → ``SchemaState`` path used by
``makemigrations``.
"""

from __future__ import annotations

import re

from .state import FieldState, SchemaState, TableState

# SurrealDB type → Python type annotation
_SURREAL_TO_PYTHON: dict[str, str] = {
    "string": "str",
    "int": "int",
    "float": "float",
    "bool": "bool",
    "datetime": "datetime",
    "duration": "str",
    "decimal": "Decimal",
    "number": "float",
    "bytes": "bytes",
    "uuid": "str",
    "object": "dict[str, Any]",
    "any": "Any",
    "geometry": "dict[str, Any]",
    "regex": "str",
}

# SurrealDB types that require extra imports
_IMPORT_MAP: dict[str, str] = {
    "datetime": "from datetime import datetime",
    "Decimal": "from decimal import Decimal",
    "Any": "from typing import Any",
}


class ModelCodeGenerator:
    """
    Generates Python model source code from a ``SchemaState``.

    Usage::

        state = await DatabaseIntrospector().introspect()
        generator = ModelCodeGenerator()
        source = generator.generate(state)

        # Write to file
        with open("models.py", "w") as f:
            f.write(source)
    """

    def generate(self, state: SchemaState) -> str:
        """
        Generate a complete Python module with model classes.

        Args:
            state: The schema state to generate models from.

        Returns:
            Python source code string.
        """
        imports: set[str] = set()
        imports.add("from __future__ import annotations")
        imports.add("")
        imports.add("from pydantic import Field")
        imports.add("")
        imports.add("from surreal_orm import BaseSurrealModel, SurrealConfigDict")

        class_blocks: list[str] = []

        for _table_name, table_state in sorted(state.tables.items()):
            block, extra_imports = self._generate_model_class(table_state)
            class_blocks.append(block)
            imports.update(extra_imports)

        # Build final source
        lines: list[str] = []
        lines.append('"""')
        lines.append("Auto-generated models from database introspection.")
        lines.append("")
        lines.append("Generated by: surreal-orm inspectdb")
        lines.append('"""')
        lines.append("")

        # Sort imports: __future__ first, then stdlib, then third-party
        sorted_imports = self._sort_imports(imports)
        lines.extend(sorted_imports)
        lines.append("")
        lines.append("")

        lines.append("\n\n".join(class_blocks))
        lines.append("")

        return "\n".join(lines)

    def _generate_model_class(self, table: TableState) -> tuple[str, set[str]]:
        """
        Generate a single model class from a TableState.

        Returns:
            (class_source, extra_imports)
        """
        extra_imports: set[str] = set()

        class_name = self._table_to_class_name(table.name)
        config_parts: list[str] = [f'table_name="{table.name}"']

        if table.table_type != "normal":
            extra_imports.add("from surreal_orm.types import TableType")
            type_map = {
                "relation": "TableType.RELATION",
                "user": "TableType.USER",
                "stream": "TableType.STREAM",
                "hash": "TableType.HASH",
                "any": "TableType.ANY",
            }
            tt = type_map.get(table.table_type, f'"{table.table_type}"')
            config_parts.append(f"table_type={tt}")

        if table.changefeed:
            config_parts.append(f'changefeed="{table.changefeed}"')

        if table.permissions:
            perm_str = repr(table.permissions)
            config_parts.append(f"permissions={perm_str}")

        if table.view_query:
            config_parts.append(f"view_query={repr(table.view_query)}")

        if table.relation_in:
            config_parts.append(f"relation_in={repr(table.relation_in)}")

        if table.relation_out:
            config_parts.append(f"relation_out={repr(table.relation_out)}")

        if table.enforced:
            config_parts.append("enforced=True")

        config_line = ", ".join(config_parts)

        lines: list[str] = []

        if table.view_query:
            lines.append("# Read-only materialized view")

        lines.append(f"class {class_name}(BaseSurrealModel):")
        lines.append(f"    model_config = SurrealConfigDict({config_line})")
        lines.append("")
        lines.append("    id: str | None = None")

        # Build a map of field → HNSW index for VectorField generation
        from .state import IndexState

        hnsw_indexes: dict[str, IndexState] = {}
        for idx in table.indexes.values():
            if idx.hnsw and len(idx.fields) == 1:
                hnsw_indexes[idx.fields[0]] = idx

        # Generate fields
        for _field_name, field_state in sorted(table.fields.items()):
            hnsw_idx = hnsw_indexes.get(field_state.name)
            if hnsw_idx and hnsw_idx.dimension:
                # Generate VectorField annotation
                extra_imports.add("from surreal_orm.fields import VectorField")
                vtype = hnsw_idx.vector_type or "F32"
                if vtype == "F32":
                    field_line = f"{field_state.name}: VectorField[{hnsw_idx.dimension}]"
                else:
                    field_line = f'{field_state.name}: VectorField[{hnsw_idx.dimension}, "{vtype}"]'
                lines.append(f"    {field_line}")
            else:
                field_line, field_imports = self._generate_field(field_state)
                lines.append(f"    {field_line}")
                extra_imports.update(field_imports)

        # Add informational comments for server-side events
        if table.events:
            lines.append("")
            lines.append("    # Server-side events (managed by SurrealDB):")
            for event_name, event_state in sorted(table.events.items()):
                lines.append(f"    # - {event_name}: WHEN {event_state.when}")

        return "\n".join(lines), extra_imports

    def _generate_field(self, field: FieldState) -> tuple[str, set[str]]:
        """
        Generate a single field line from a FieldState.

        Returns:
            (field_line, extra_imports)
        """
        extra_imports: set[str] = set()
        python_type = self._surreal_type_to_python(field.field_type)

        # Collect any needed imports from the type
        self._collect_type_imports(python_type, extra_imports)

        # Handle nullable; avoid duplicating None for option<T> types
        if field.nullable and "None" not in python_type:
            python_type = f"{python_type} | None"

        # Handle computed fields (VALUE clause)
        if field.value and not field.encrypted:
            extra_imports.add("from surreal_orm.fields import Computed")
            return (
                f'{field.name}: Computed[{python_type}] = Computed("{field.value}")',
                extra_imports,
            )

        # Handle encrypted fields
        if field.encrypted:
            extra_imports.add("from surreal_orm.fields import Encrypted")
            return f"{field.name}: Encrypted", extra_imports

        # Build Field() kwargs
        field_kwargs: list[str] = []

        if field.default is not None:
            default_repr = self._format_default(field.default)
            field_kwargs.append(f"default={default_repr}")

        if field.readonly:
            field_kwargs.append("readonly=True")

        if field_kwargs:
            kwargs_str = ", ".join(field_kwargs)
            return f"{field.name}: {python_type} = Field({kwargs_str})", extra_imports

        # Simple field with no extras
        if field.nullable:
            return f"{field.name}: {python_type} = None", extra_imports

        return f"{field.name}: {python_type}", extra_imports

    def _surreal_type_to_python(self, surreal_type: str) -> str:
        """
        Convert a SurrealDB type string to a Python type annotation.

        Handles generic types like ``array<string>``, ``option<int>``,
        ``record<users>``, ``set<string>``.
        """
        surreal_type = surreal_type.strip()

        # Handle option<T>
        option_match = re.match(r"option<(.+)>", surreal_type, re.IGNORECASE)
        if option_match:
            inner = self._surreal_type_to_python(option_match.group(1))
            return f"{inner} | None"

        # Handle array<T>
        array_match = re.match(r"array<(.+)>", surreal_type, re.IGNORECASE)
        if array_match:
            inner = self._surreal_type_to_python(array_match.group(1))
            return f"list[{inner}]"

        # Handle set<T>
        set_match = re.match(r"set<(.+)>", surreal_type, re.IGNORECASE)
        if set_match:
            inner = self._surreal_type_to_python(set_match.group(1))
            return f"set[{inner}]"

        # Handle record<T>
        record_match = re.match(r"record<(.+)>", surreal_type, re.IGNORECASE)
        if record_match:
            return "str"  # Record references are stored as string IDs

        # Handle geometry<T> → GeoField["T"]
        geo_match = re.match(r"geometry<(.+)>", surreal_type, re.IGNORECASE)
        if geo_match:
            geo_type = geo_match.group(1).strip().lower()
            return f'GeoField["{geo_type}"]'

        # Simple type lookup
        return _SURREAL_TO_PYTHON.get(surreal_type.lower(), "Any")

    def _collect_type_imports(self, python_type: str, imports: set[str]) -> None:
        """Add required imports based on the Python type annotation."""
        for type_name, import_line in _IMPORT_MAP.items():
            if type_name in python_type:
                imports.add(import_line)
        if "GeoField" in python_type:
            imports.add("from surreal_orm.fields import GeoField")

    def _format_default(self, default: object) -> str:
        """Format a default value for Python source code."""
        if isinstance(default, str):
            # Check if it's a function call (e.g., time::now())
            if "::" in default or "(" in default:
                return f'"{default}"'
            return repr(default)
        if isinstance(default, bool):
            return "True" if default else "False"
        if isinstance(default, (int, float)):
            return str(default)
        return repr(default)

    @staticmethod
    def _table_to_class_name(table_name: str) -> str:
        """Convert a table name to a PascalCase class name.

        ``users`` → ``User``
        ``game_tables`` → ``GameTable``
        ``has_player`` → ``HasPlayer``
        """
        parts = table_name.split("_")
        # Singularize the last part (naive: strip trailing 's')
        if parts[-1].endswith("s") and len(parts[-1]) > 1:
            parts[-1] = parts[-1][:-1]
        return "".join(part.capitalize() for part in parts)

    @staticmethod
    def _sort_imports(imports: set[str]) -> list[str]:
        """Sort imports in PEP8 order."""
        future: list[str] = []
        stdlib: list[str] = []
        third_party: list[str] = []

        stdlib_modules = {"datetime", "decimal", "typing", "uuid", "re", "os", "sys"}

        for imp in imports:
            if not imp.strip():
                continue
            if "__future__" in imp:
                future.append(imp)
            elif any(f"from {mod}" in imp or f"import {mod}" in imp for mod in stdlib_modules):
                stdlib.append(imp)
            else:
                third_party.append(imp)

        result: list[str] = []
        if future:
            result.extend(sorted(future))
            result.append("")
        if stdlib:
            result.extend(sorted(stdlib))
            result.append("")
        if third_party:
            result.extend(sorted(third_party))

        return result


__all__ = ["ModelCodeGenerator"]
